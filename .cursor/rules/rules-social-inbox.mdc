---
alwaysApply: true
---
## ğŸ—ï¸ Arquitectura y Patrones

### Multi-Tenancy
```typescript
// REGLA CRÃTICA: SIEMPRE filtrar por tenantId
// âŒ MAL - Expone datos de otros tenants
const channels = await prisma.channel.findMany()

// âœ… BIEN - Filtra por tenant
const channels = await prisma.channel.findMany({
  where: {
    local: {
      tenantId: tenantId
    }
  }
})

// SIEMPRE verificar ownership antes de operaciones:
const channel = await prisma.channel.findUnique({
  where: { id: channelId },
  include: { local: true }
})

if (channel.local.tenantId !== tenantId) {
  return { error: "Unauthorized" }
}
```

### Server Actions
```typescript
// Estructura estÃ¡ndar de server action:
export async function myAction(data: MyData) {
  try {
    // 1. AutenticaciÃ³n
    const user = await requireAuth()
    
    // 2. AutorizaciÃ³n
    const membership = await checkTenantAccess(user.id!, data.tenantId)
    if (!membership) {
      return { error: "Unauthorized" }
    }
    
    // 3. ValidaciÃ³n de permisos especÃ­ficos
    if (membership.role !== "OWNER" && membership.role !== "ADMIN") {
      return { error: "Insufficient permissions" }
    }
    
    // 4. ValidaciÃ³n de datos
    const validated = mySchema.safeParse(data)
    if (!validated.success) {
      return { error: "Invalid data" }
    }
    
    // 5. Verificar ownership de recursos
    const resource = await prisma.resource.findUnique({
      where: { id: data.resourceId },
      include: { tenant: true }
    })
    
    if (resource.tenantId !== data.tenantId) {
      return { error: "Resource not found" }
    }
    
    // 6. OperaciÃ³n principal
    const result = await prisma.resource.update({ ... })
    
    // 7. Revalidar cache
    revalidatePath(`/app/${data.tenantId}/path`)
    
    // 8. Retornar resultado
    return { success: true, data: result }
    
  } catch (error) {
    console.error("[Action Name] Error:", error)
    return { error: "Operation failed" }
  }
}
```

### Componentes Client vs Server

```typescript
// Server Components (por defecto):
// - Fetch de datos
// - Acceso directo a BD
// - No necesitan "use client"
// - Mejor performance y SEO

// Client Components ("use client"):
// - Interactividad (onClick, onChange, etc)
// - Hooks (useState, useEffect, etc)
// - NavegaciÃ³n (useRouter, usePathname)
// - Context (useContext)

// âŒ MAL - Server component con interactividad
export default function MyPage() {
  const [state, setState] = useState() // Error!
  return <button onClick={() => {}}>Click</button>
}

// âœ… BIEN - Separar responsabilidades
// page.tsx (Server Component)
export default async function MyPage() {
  const data = await fetchData()
  return <MyClientComponent data={data} />
}

// my-client-component.tsx (Client Component)
"use client"
export function MyClientComponent({ data }) {
  const [state, setState] = useState()
  return <button onClick={() => setState(...)}>Click</button>
}
```

---

## ğŸ’¾ Base de Datos y Prisma

### Queries Optimizadas
```typescript
// SIEMPRE usar select para limitar campos
// âŒ MAL - Trae todos los campos
const users = await prisma.user.findMany()

// âœ… BIEN - Solo campos necesarios
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    email: true
  }
})

// SIEMPRE usar Ã­ndices en where clauses
// Los Ã­ndices estÃ¡n definidos en schema.prisma con @@index

// NUNCA usar include y select juntos
// âŒ MAL
const channel = await prisma.channel.findMany({
  include: { local: true },
  select: { id: true } // Error!
})

// âœ… BIEN - Solo uno
const channel = await prisma.channel.findMany({
  select: {
    id: true,
    local: {
      select: { name: true }
    }
  }
})
```

### Transacciones
```typescript
// Para operaciones mÃºltiples relacionadas:
await prisma.$transaction(async (tx) => {
  const tenant = await tx.tenant.create({ ... })
  const local = await tx.local.create({ ... })
  const membership = await tx.membership.create({ ... })
  return { tenant, local, membership }
})

// NUNCA hacer queries dependientes sin transacciÃ³n
// si una falla, las otras quedan inconsistentes
```

### Migraciones
```bash
# SIEMPRE crear migraciones para cambios de schema
npm run db:migrate

# NUNCA usar db:push en producciÃ³n
# SOLO usar db:push en desarrollo

# SIEMPRE revisar la migraciÃ³n generada antes de aplicar
# Verificar que no borra datos importantes
```

---

## ğŸ¨ Frontend y UI

### Componentes shadcn/ui
```typescript
// SIEMPRE usar componentes de /components/ui/
// NO crear componentes UI desde cero

// SIEMPRE usar las variantes definidas
<Button variant="outline" size="sm">Click</Button>

// SIEMPRE usar className para estilos adicionales
<Button className="mt-4">Click</Button>

// NUNCA modificar componentes de /components/ui/ directamente
// Si necesitas customizaciÃ³n, crea un wrapper
```

### Tailwind CSS
```typescript
// SIEMPRE usar clases de Tailwind
// NO usar CSS inline o archivos CSS custom

// âœ… BIEN
<div className="flex items-center gap-4 rounded-lg border p-4">

// âŒ MAL
<div style={{ display: 'flex', gap: '16px' }}>

// Usar dark mode con prefijo dark:
<div className="bg-white dark:bg-gray-900">

// Usar responsive con prefijos md:, lg:
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
```

### Formularios
```typescript
// SIEMPRE validar en cliente Y servidor
// Cliente: UX inmediata
// Servidor: Seguridad real

// SIEMPRE usar FormData o estado controlado
const [value, setValue] = useState("")

// SIEMPRE deshabilitar botones durante submit
<Button disabled={isSubmitting}>
  {isSubmitting ? "Guardando..." : "Guardar"}
</Button>

// SIEMPRE mostrar feedback con toast
import { toast } from "sonner"
toast.success("OperaciÃ³n exitosa")
toast.error("Error al guardar")
```

### Estados de Carga
```typescript
// SIEMPRE mostrar estados de carga
// - Skeleton para listas
// - Spinner para operaciones
// - Texto en botones

// âœ… BIEN
{isLoading ? (
  <Skeleton className="h-20 w-full" />
) : (
  <DataComponent data={data} />
)}

// SIEMPRE usar Suspense para async components
<Suspense fallback={<LoadingSkeleton />}>
  <AsyncComponent />
</Suspense>
```

---

## ğŸ”„ Manejo de Errores

### Try-Catch
```typescript
// SIEMPRE usar try-catch en server actions
try {
  // operaciÃ³n
} catch (error) {
  console.error("[Context] Error:", error)
  return { error: "User-friendly message" }
}

// NUNCA exponer detalles tÃ©cnicos al usuario
// âŒ MAL
return { error: error.message } // Puede exponer info sensible

// âœ… BIEN
return { error: "Failed to save data" }
```

### Error Boundaries
```typescript
// SIEMPRE tener error boundaries en pÃ¡ginas crÃ­ticas
// Next.js usa error.tsx automÃ¡ticamente

// app/[tenantId]/error.tsx
'use client'
export default function Error({ error, reset }) {
  return (
    <div>
      <h2>Algo saliÃ³ mal</h2>
      <button onClick={reset}>Reintentar</button>
    </div>
  )
}
```

---

## ğŸš€ Performance

### Optimizaciones
```typescript
// SIEMPRE usar React.memo para componentes pesados
export const HeavyComponent = React.memo(({ data }) => {
  // render pesado
})

// SIEMPRE usar useMemo para cÃ¡lculos costosos
const expensiveValue = useMemo(() => {
  return heavyCalculation(data)
}, [data])

// SIEMPRE usar useCallback para funciones en props
const handleClick = useCallback(() => {
  doSomething()
}, [dependency])

// NUNCA hacer queries en loops
// âŒ MAL
for (const item of items) {
  await prisma.item.findUnique({ where: { id: item.id } })
}

// âœ… BIEN
const ids = items.map(i => i.id)
const results = await prisma.item.findMany({
  where: { id: { in: ids } }
})
```

### ImÃ¡genes
```typescript
// SIEMPRE usar next/image
import Image from "next/image"

<Image
  src="/image.jpg"
  alt="Description"
  width={500}
  height={300}
  priority // Para above-the-fold
/>

// NUNCA usar <img> directamente
```

### Caching
```typescript
// SIEMPRE usar revalidatePath despuÃ©s de mutaciones
import { revalidatePath } from "next/cache"

await prisma.channel.update({ ... })
revalidatePath(`/app/${tenantId}/channels`)

// SIEMPRE usar cache en fetch cuando sea apropiado
fetch(url, { next: { revalidate: 3600 } }) // 1 hora
```

---

## ğŸ“ CÃ³digo Limpio

### Nomenclatura
```typescript
// Variables y funciones: camelCase
const userName = "John"
function getUserData() {}

// Componentes y Tipos: PascalCase
interface UserData {}
function UserCard() {}

// Constantes: UPPER_SNAKE_CASE
const MAX_RETRIES = 3
const API_BASE_URL = "https://api.example.com"

// Archivos:
// - Componentes: kebab-case.tsx (user-card.tsx)
// - Utilidades: kebab-case.ts (auth-utils.ts)
// - Server Actions: kebab-case.ts (channels.ts)

// SIEMPRE usar nombres descriptivos
// âŒ MAL
const d = new Date()
const fn = () => {}

// âœ… BIEN
const createdAt = new Date()
const handleSubmit = () => {}
```

### Comentarios
```typescript
// SIEMPRE comentar lÃ³gica compleja
// Calcular SLA considerando horarios de negocio
const slaStatus = calculateSLA(thread, config)

// SIEMPRE comentar "por quÃ©", no "quÃ©"
// âŒ MAL
// Incrementar contador
counter++

// âœ… BIEN
// Incrementar para evitar race condition en concurrent requests
counter++

// SIEMPRE usar JSDoc para funciones pÃºblicas
/**
 * Conecta un nuevo canal de mensajerÃ­a
 * @param data - ConfiguraciÃ³n del canal
 * @returns Promise con resultado de la operaciÃ³n
 */
export async function connectChannel(data: ConnectChannelData) {}
```

### OrganizaciÃ³n de Imports
```typescript
// Orden de imports:
// 1. React y Next.js
import { useState } from "react"
import { useRouter } from "next/navigation"

// 2. LibrerÃ­as externas
import { toast } from "sonner"

// 3. Componentes UI
import { Button } from "@/components/ui/button"
import { Dialog } from "@/components/ui/dialog"

// 4. Componentes propios
import { ChannelCard } from "@/components/channels/channel-card"

// 5. Utilidades y tipos
import { cn } from "@/lib/utils"
import type { Channel } from "@prisma/client"

// 6. Iconos (al final)
import { Plus, Settings } from "lucide-react"
```

### Funciones
```typescript
// SIEMPRE mantener funciones pequeÃ±as (< 50 lÃ­neas)
// Si es mÃ¡s grande, dividir en funciones mÃ¡s pequeÃ±as

// SIEMPRE un solo nivel de abstracciÃ³n por funciÃ³n
// âŒ MAL - Mezcla niveles
function processUser() {
  const user = await db.user.find() // bajo nivel
  validateUser(user) // alto nivel
  const x = user.name.toLowerCase() // bajo nivel
}

// âœ… BIEN - Mismo nivel
async function processUser() {
  const user = await getUser()
  validateUser(user)
  normalizeUser(user)
}

// SIEMPRE retornar early para evitar nesting
// âŒ MAL
function process(data) {
  if (data) {
    if (data.valid) {
      if (data.active) {
        // cÃ³digo
      }
    }
  }
}

// âœ… BIEN
function process(data) {
  if (!data) return
  if (!data.valid) return
  if (!data.active) return
  // cÃ³digo
}
```

---

## ğŸ§ª Testing (Futuro)

### Estructura de Tests
```typescript
// Unit tests para:
// - Utilidades (sla.ts, utils.ts)
// - Adapters (parsing de webhooks)
// - Validaciones (schemas de Zod)

// Integration tests para:
// - Server actions
// - API routes
// - Webhook handlers

// E2E tests para:
// - Flujos crÃ­ticos (login, enviar mensaje, asignar thread)
// - Casos de uso principales

// SIEMPRE mockear servicios externos
// SIEMPRE limpiar BD despuÃ©s de tests
// NUNCA usar datos de producciÃ³n en tests
```

---

## ğŸ”Œ Adapters de Canales

### ImplementaciÃ³n
```typescript
// SIEMPRE implementar interface ChannelAdapter
export class MyAdapter implements ChannelAdapter {
  type = "MY_CHANNEL"
  
  async ingestWebhook(payload: any, channelId: string): Promise<MessageDTO | null> {
    // Parsear webhook
  }
  
  async sendMessage(channelId: string, message: SendMessageDTO): Promise<Result> {
    // Enviar mensaje
  }
  
  async listThreads(channelId: string): Promise<ThreadDTO[]> {
    // Listar conversaciones
  }
  
  verifyWebhook(payload: any, signature: string): boolean {
    // Verificar firma HMAC
  }
}

// SIEMPRE obtener credenciales de channel.meta
const channel = await prisma.channel.findUnique({ where: { id: channelId } })
const { accessToken, pageId } = channel.meta

// SIEMPRE manejar errores de API externa
try {
  const response = await fetch(apiUrl, { ... })
  if (!response.ok) {
    return { success: false, error: `API error: ${response.status}` }
  }
} catch (error) {
  return { success: false, error: "Network error" }
}

// SIEMPRE usar idempotencia con externalId
// Evita duplicados si el webhook se reenvÃ­a
```

---

## ğŸ”„ Queue y Workers (BullMQ)

### Jobs
```typescript
// SIEMPRE encolar operaciones asÃ­ncronas
await messageQueue.add("send-message", {
  channelId,
  messageId,
  message
})

// SIEMPRE implementar retry logic
{
  attempts: 3,
  backoff: {
    type: 'exponential',
    delay: 2000
  }
}

// SIEMPRE actualizar estado en BD
if (result.success) {
  await prisma.message.update({
    where: { id: messageId },
    data: { deliveredAt: new Date() }
  })
} else {
  await prisma.message.update({
    where: { id: messageId },
    data: { failedReason: result.error }
  })
}
```

---

## ğŸ“Š Logging y Monitoreo

### Logs
```typescript
// SIEMPRE usar prefijos descriptivos
console.log("[Channel Connect] Creating new channel")
console.error("[Send Message] Failed to send:", error)

// SIEMPRE loggear operaciones importantes
console.log("[Auth] User logged in:", user.email)
console.log("[Webhook] Message received from:", channelId)

// NUNCA loggear informaciÃ³n sensible
// âŒ MAL
console.log("Access token:", token)
console.log("Password:", password)

// âœ… BIEN
console.log("Token length:", token?.length)
console.log("User authenticated")
```

---

## ğŸŒ InternacionalizaciÃ³n

### Idioma
```typescript
// SIEMPRE usar espaÃ±ol en:
// - Textos de UI
// - Mensajes de error para usuarios
// - Comentarios en cÃ³digo
// - Nombres de variables (cuando tenga sentido)

// InglÃ©s solo para:
// - Nombres de funciones y componentes
// - CÃ³digo tÃ©cnico
// - LibrerÃ­as y frameworks

// âœ… BIEN
const nombreUsuario = user.name
toast.error("Error al guardar los cambios")
// Validar permisos del usuario

// âŒ MAL (mezclar idiomas)
const userName = user.name
toast.error("Failed to save changes")
// Validate user permissions
```

---

## ğŸš« Anti-Patrones a Evitar

### NUNCA hacer esto:
```typescript
// âŒ Queries sin filtro de tenant
const data = await prisma.channel.findMany()

// âŒ Confiar en datos del cliente
const { tenantId } = req.body // Usuario puede manipular esto

// âŒ Usar any sin necesidad
function process(data: any) {} // Pierde type safety

// âŒ Mutar props directamente
props.data.push(item) // Props son inmutables

// âŒ Usar Ã­ndices como keys en listas
{items.map((item, i) => <div key={i}>{item}</div>)}

// âŒ Hacer fetch en useEffect sin cleanup
useEffect(() => {
  fetch(url).then(setData)
}, []) // Memory leak si componente se desmonta

// âŒ Hardcodear valores
const apiUrl = "https://api.example.com" // Usar env vars

// âŒ Catch sin manejo
try { ... } catch (e) {} // Al menos loggear

// âŒ Operaciones sÃ­ncronas bloqueantes
const data = fs.readFileSync() // Usar async

// âŒ Queries en loops
for (const id of ids) {
  await prisma.user.findUnique({ where: { id } })
}
```

---

## âœ… Checklist Pre-Commit

Antes de cada commit, verificar:

- [ ] Â¿AgreguÃ© validaciÃ³n de autenticaciÃ³n?
- [ ] Â¿VerifiquÃ© permisos de tenant?
- [ ] Â¿ValidÃ© los datos de entrada?
- [ ] Â¿ManejÃ© todos los errores?
- [ ] Â¿AgreguÃ© revalidatePath despuÃ©s de mutaciones?
- [ ] Â¿UsÃ© tipos de TypeScript correctamente?
- [ ] Â¿Los componentes tienen nombres descriptivos?
- [ ] Â¿AgreguÃ© comentarios para lÃ³gica compleja?
- [ ] Â¿OptimicÃ© las queries de Prisma?
- [ ] Â¿ProbÃ© la funcionalidad manualmente?
- [ ] Â¿No hay console.logs de debug?
- [ ] Â¿No hay credenciales hardcodeadas?
- [ ] Â¿Los textos estÃ¡n en espaÃ±ol?
- [ ] Â¿ActualicÃ© el PLAN.md si completÃ© una tarea?

---

## ğŸ¯ Prioridades de Desarrollo

### Orden de implementaciÃ³n:
1. **Seguridad primero**: Auth, permisos, validaciÃ³n
2. **Funcionalidad core**: Features principales
3. **UX/UI**: Polish, animaciones, feedback
4. **Performance**: Optimizaciones, caching
5. **Testing**: Tests automatizados
6. **DocumentaciÃ³n**: Docs, comentarios

### Cuando tengas dudas:
1. Â¿Es seguro? â†’ Si no, arreglarlo primero
2. Â¿Funciona? â†’ Si no, hacerlo funcionar
3. Â¿Es claro? â†’ Si no, refactorizar
4. Â¿Es rÃ¡pido? â†’ Si no, optimizar

---

## ğŸ“š Recursos y Referencias

### DocumentaciÃ³n oficial:
- Next.js 15: https://nextjs.org/docs
- Prisma: https://www.prisma.io/docs
- NextAuth v5: https://authjs.dev
- shadcn/ui: https://ui.shadcn.com
- Tailwind CSS: https://tailwindcss.com/docs

### Patrones del proyecto:
- Ver `/lib/adapters/` para implementar nuevos canales
- Ver `/app/actions/` para estructura de server actions
- Ver `/components/channels/` para componentes de UI
- Ver `/prisma/schema.prisma` para modelo de datos

---

## ğŸ¤ ColaboraciÃ³n

### Al pedir ayuda:
- Incluir contexto completo
- Mostrar cÃ³digo relevante
- Describir comportamiento esperado vs actual
- Incluir mensajes de error completos

### Al revisar cÃ³digo:
- Verificar seguridad primero
- Revisar lÃ³gica de negocio
- Validar tipos de TypeScript
- Comprobar manejo de errores
- Verificar performance

---

**Recuerda**: CÃ³digo que funciona hoy pero es inseguro o difÃ­cil de mantener, causarÃ¡ problemas maÃ±ana. Siempre prioriza calidad sobre velocidad.

**MantÃ©n estas reglas actualizadas** a medida que el proyecto evoluciona y se descubren nuevos patrones o problemas.
